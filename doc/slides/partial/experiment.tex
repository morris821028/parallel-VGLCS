\section{Experiment}

\subsection{Environment Settings}
\begin{frame}
    \frametitle{Environment}
\end{frame}

\subsection{Parallel VGLCS}
\begin{frame}
	\frametitle{Runtime}
	\begin{figure}[!ht]
		\centering
		\subfigure[Runtime]{
			\input{./figure/fig-parallel-n}
			\label{fig:fig-parallel}
		}
		%\subfigure[Little core cluster]{
		%	\input{./data/light_little}
		%	\label{fig:light_little}
		%}
		\caption{Serial Algorithm and Parallel Algorithm}
		\label{fig:light_weight}
	\end{figure}
\end{frame}

\begin{frame}
	\frametitle{Scalability}
	\begin{figure}[!ht]
		\centering
		\subfigure[Scalability]{
			\input{./figure/fig-parallel-p}
			\label{fig:fig-parallel}
		}
		%\subfigure[Little core cluster]{
		%	\input{./data/light_little}
		%	\label{fig:light_little}
		%}
		\caption{Parallel Algorithm}
		\label{fig:light_weight}
	\end{figure}
\end{frame}

\subsection{Parallel RMQ and Cache-Oblivious Cartesian Tree}
\begin{frame}
	\frametitle{Speedup}
	We have $N$ elements of an array and $N$ querys.
	\begin{itemize}
		\setlength\itemsep{1em}
		\item When $N = 30000$ and maximum length of interval $L \le 100$, \texttt{CORQM} can speedup $1.25\times$ 
		because of less cache-misses.
	\end{itemize}
\end{frame}