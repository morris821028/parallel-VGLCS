\section{結論}
\label{sec:Conclusion}

這篇論文中，我們提出以列接列的平行方法，將兩階段 VGLCS 算法充分平行，
而提出的兩階段的算法相較於一般的波前平行方法來得更有效率，
且運行的規律性和其易實作造就更好的效能。

我們使用「稀疏表」來解決可變的間隙限制最常共同子序列，
而稀疏表可在平行環境下提供更好的同步效能和均勻的工作負載，
這些都是並查集無法達到的。此外，我們提出「右側棧出」編碼，
其易於實作且運行地相當高效於平行環境。最後，我們的 VGLCS 算法使用「右側棧出」的稀疏表，
運行時間為 $O(n^2 s / p + n \; \max(\log n, s))$，
其中 $n$ 為元素個數、$p$ 為處理器個數、$s$ 為塊大小。

我們提出的標記方法採用字典順序，將任意二元搜尋樹找到相應的卡塔蘭索引值，
接著使用這一標記方法提供笛卡爾樹的編碼方式於攤銷 $O(1)$ 時間，
最後，VGLCS 問題使用這些技巧於時間 $O(n^2 / p + n \log n)$ 內被解決。

我們提出的動態卡塔蘭索引值的算法，搭配稀疏表可解決增長區間最大質詢問，
每一詢問可在攤銷時間 $O(1)$ 解決，使得 VGLCS 算法的時間複雜度為 $O(n^2 / p + n \log n)$。
特別注意到動態卡塔蘭索引值計算，可以普遍使用在數據不斷插入的二元樹的情況下。

從實驗中觀察到兩個有趣的結果：
其一，在平行環境下，塊狀稀疏表效能上比未分塊的稀疏表好上許多，適當大小的塊更能給予更好的效能。
其二，漸近最好的算法在實作中，未必能提供最好效能，如我們提出的「右側棧出」編碼在詢問操作為 $O(s)$ 時間，
實際表現遠比理論攤銷時間 $O(1)$ 來得更好。最後，我們相信易於實作且直觀的算法將會是高效能的關鍵。