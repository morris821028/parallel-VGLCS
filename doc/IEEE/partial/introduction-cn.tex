\section{介紹} %Introduction
\label{sec:Introduction}

最長共同子字串 ({\em Longest Common Subsequence}，簡稱 LCS)~
\cite{Hirschberg1975ALS} 經常使用在字串處理中的經典問題。
例如說，我們使用 {\tt diff} 工具來呈現兩段文字不同的差異，找到它們最長的共同子序列；
在版本控制系統中，SVN 和 Git 也經常使用 LCS 來呈現變動情況；
在分子生物學中，生物序列對齊問題~\cite{mount2001bioinformatics,
Ann2010EfficientAF} 的其中一種 DNA、RNA 和蛋白質相似度也經常使用 LCS 表示之。

Iliopoulos 和 Rahman~\cite{Rahman2006AlgorithmsFC} 介紹在 LCS 問題下各種不同的約束變形。
例如固定間距的 LCS ({\em fixed gap LCS}，簡稱 FGLCS)，要求挑選位置之間最多間隔 $k+1$ 個字元。
對於輸入長度分別為 $n$ 和 $m$ 的字串，我們已知 FGLCS 可以在 $O(nm)$ 內被解決~\cite{Rahman2006AlgorithmsFC}。
在另一個問題可變間距 LCS ({\em variable gap LCS}，簡稱 VGLCS)
，對於兩個相鄰的挑選位置，至多間隔後者提供的約束距離加一。
因此，可以視 FGLCS 為 VGLCS 的特例，對於每一個位置提供的約束距離皆為 $k$。

\begin{figure}[!thb]
  \centering
  \includegraphics[width=0.45\linewidth]{\GraphicPath/fig-VGLCSex.pdf}
  \includegraphics[width=0.45\linewidth]{\GraphicPath/fig-VGLCSex2.pdf}
  \caption{A VGLCS example} \label{fig:VGLCSex}
\end{figure}

We use an example to illustrate the gap function and VGLCS.  Let string
$A$ be {\tt GCGCAATG} with gap values $(3, 1, 1, 2, 0, 0, 2, 1)$, and
let string $B$ be {\tt GCCCTAGCG} with gap values $(2, 0, 3, 2, 0, 1, 2,
0, 1)$.  Please refer to Figure~\ref{fig:VGLCSex} for an illustration.
Now, the LCS $GCCT$ is a VGLCS because every character in the LCS can
find its predecessor in the LCS with distance at most its gap value plus
1.

This paper focuses on {\em efficient parallel algorithms} that find
VGLCS.  Peng~\cite{Peng2011TheLC} gives a $O(nm \alpha(n))$ algorithm
that is easy to implement and an asymptotically better $O(nm)$
algorithm, where $\alpha$ is the inverse of Ackermann's
function~\cite{Banachowski1980ACT}.  In this paper, we propose our
$O(nm)$ algorithm which is {\em easy} to implement and runs {\em
efficiently} in a {\em parallel} environment.

The parallelization of LCS on most multi-core platforms focuses on
{\em wavefront} parallelism.  The wavefront parallelism is motivated
by the recursive solution of LCS.  For example,
Yang~\cite{Yang2010AnEP} introduced a new formulation to exploit more
cache performance.  Our algorithm uses a more powerful {\em sparse
  table} instead of the disjoint set in the Peng's serial algorithm
and achieves better cache performance.

The remainder of the paper is organized as follows.  In
Section~\ref{sec:parallelVGLCS}, we present previous parallel algorithms
for finding VGLCS.  In Section~\ref{sec:parallelRMQ} and \ref{sec:QIUD},
we present our algorithm that is easy to parallelize, and has a time
complexity $O(nm)$, which is better than previous works.  In
Section~\ref{sec:Implementation} and \ref{sec:Experiment}, we describe
our optimized implementation and the results of our experiments.
Section~\ref{sec:Conclusion} conclude this paper with lessons learned
and possible future works.

