\section{Query on Incrementally Updated Data} \label{sec:parallelIRMQ}

Recall that our VGLCS algorithm has two stages.  In the first stage,
the algorithm uses incremental suffix maximum query to compute
intermediate data on every {\em column} of a two dimensional matrix.
In the second stage, the algorithm uses {\em ranged maximum query} on
the rows of the matrix from the first stage to get the final answers.
These two stages work together to find the maximum in a given
rectangle area.

The implementation for two stages have different challenges.  The
first stage is easier to parallelize because the operations on
individual columns are independent.  However, it will insert new data
into the data structure, and it still needs to answer ranged query
efficiently. The second stage does not requires insertion so it is
more static, and easier.  However, it requires working on several
columns simultaneously and synchronously.  Fortunately we have address
this data synchronous issue by computing the index table in a off-line
manner, as described in previous Section~\ref{sec:parallelIRMQ}.  As a
result in this section we will focus on how to answer ranged maximum
queries efficiently on {\em incrementally} updated data.

% not here, somewhere else
%\input{./tables/tlb-cmp-complexity.tex}

\subsection{Build a Lookup Table for LCA}

% why LCA is importnat

To find the lowest common ancestor is important for answering ranged
maximum queries, which is important to find VGLCS.  We need to address
two issues -- how to encode a binary tree and how to find the lowest
common ancestor under the given tree encoding.

%% In VGLCS problem, we could not use sorting to improve cache miss
%% because the number of elements and queries are similar.  

\subsubsection{Cartesian Tree Encoding}

Our Cartesian tree encoding method lists {\em all} binary search trees
in {\em lexicographical order} and label them from $0$ to the $n$-th
Catalan number minus 1.  The lexicographical order among binary search
trees of the {\em same} number of nodes is defined {\em recursively}
as follows.  A binary tree $a$ appears {\em before} another binary if
$a$ has more nodes than $b$ in the left subtree, or $a$ and $b$ has
the same number of nodes in the left subtree, and $a$'s left subtree
appears before $b$'s left subtree in lexicographical order, or $a$ and
$b$ has the same left subtree, and $a$'s right subtree appears before
$b$'s right subtree in lexicographical order.
Figure~\ref{fig:labelingBST} shows our labeling of binary search tree
for 1, 2 and 3 nodes.

\begin{figure}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-bst-encoding.pdf}
  \caption{The labeling of binary search trees}
  \label{fig:labelingBST}
\end{figure}

\subsubsection{Lowest Common Ancestor}

We also need to determine the lowest common ancestor efficiently for
answering ranged maximum queries.  For ease of discussion we define
several notations.  Let $t$ be the index of the search tree in our
encoding, so $t$ is between 0 and $s - 1$, where $s$ is the number of
search trees.  Let ${\cal A}(s, t, p, q)$ denote the {\em lowest
  common ancestor} of the node $p$ and $q$ within a binary search tree
with $s$ nodes and label $t$.  For example, ${\cal A}(3, 2, 0, 2) = 1$
from Figure~\ref{fig:labelingBST}.  Also we consider the tree of $s$
nodes with label $t$, and let $l_s$ denote the size of the left
subtree, $r_s$ denote the size of the right subtree, $l_t$ be the
label of its left subtree, and $r_t$ be the label of its right
subtree.  With these notations we can define the lowest common
ancestor {\em recursively} as in Equation~\ref{fun:LCA1} when $l_s
\le p \le q < n$.  Other cases are defined in Equation~\ref{fun:LCA2}.

\input{./formulas/fun-LCA.tex}

In order to store all binary search trees, the space complexity of
Algorithm~\ref{alg:parallel-LCA} is in Equation~\ref{eq:space}, and the
time complexity of parallel Algorithm~\ref{alg:parallel-LCA} is in
Equation~\ref{eq:parallel-time}.

% need a formal proof here for the space and time complexity.

The lookup table records the all the binary tree with the number of tree
nodes from 1 to $s$.  When the number of tree nodes is $n$, the number
of rooted binary trees is the $n$-th Catalan number $C_n$, which $C_n =
\frac{1}{n+1}\binom{2n}{n} = O(\frac{4^n}{n^{1.5}})$.  For each binary
tree, we store the lowest common ancestor of every pair of nodes into
table, and the number of pairs is $O(n^2)$.  Therefore, the space
complexity is $O(s \times \frac{1}{s+1}\binom{2s}{s} \times s^2)$
corresponding the number of the answers in different binary trees.  When
pick $s = \frac{\log n}{4}$, the space complexity is $O(n)$.

The Algorithm~\ref{alg:parallel-LCA} compute all the answers.  Because
the number of answers is $O(\frac{s^3}{s+1} \binom{2s}{s})$ and the cost
of translation in formula is $O(1)$.  The sequence version run in
$O(\frac{s^3}{s+1} \binom{2s}{s})$ time.  With $p$ processor, we find
that all the computation in the same number of tree nodes are
independent, but the time complexity of finding
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$ is
$O(s)$.  Therefore, the parallel algorithm can be found in $O(s^2)$ time
easily.

\begin{equation} \label{eq:space}
O\left(\frac{s^3}{s+1} \binom{2s}{s}\right) =
O\left(n\right)
\end{equation}

\begin{equation} \label{eq:parallel-time}
O\left(\frac{s^3}{s+1} \binom{2s}{s} \bigg/ p + s^2 \right)
\end{equation}.

% how to compute subtree information from t

Note that in line 4 of Algorithm~\ref{alg:parallel-LCA}, when given
the tree id $t$, we need to compute the sizes and ids of the left and
right subtrees in our encoding.  We can do this in $O(n)$ time, where
$n$ is the number of tree nodes.

\input{algorithms/alg-parallel-LCA.tex}


\subsection{Tree Index Computation}

Note that Algorithm~\ref{alg:parallel-LCA} requires tree index $t$
under our encoding scheme, so we need to determine $t$ efficiently,
given a block of data.

% how to compute t from tree data structure

One way to determine the tree index $t$ is to build the tree and
compute it from the the sizes and ids of the left and right subtrees.
This require a recursive traversal on the tree and has a $O(n)$ time
complexity, where $n$ is the number of tree nodes.  The pseudo code of
the conversion is given as Algorithm~\ref{alg:encode-tid}.

\input{algorithms/alg-encode-tid}

We can further optimize Algorithm~\ref{alg:encode-tid} by
pre-computing the prefix sum of Catalan numbers, and store them in
memory, so that we can use them directly, instead of recomputing them
in Algorithm~\ref{alg:encode-tid}.  That is, we can pre-compute these
offsets, and replace the loop at line 6 of
Algorithm~\ref{alg:encode-tid} with a table lookup.

% how to compute t with rightmost path of the tree

In order to find the index of the block, we build a Cartesian tree
corresponding to the elements of the block, and then find the id of the
Cartesian tree. The previous computation of tree index requires build
the tree to obtain subtree information, and may not be efficient.  We
propose a method that keeps only the {\em rightmost path} in a stack
without building the entire tree.  After knowing tree index $t$ we can
compute LCA and answer queries with Algorithm~\ref{alg:parallel-LCA}.

We compute the tree index $t$ on the rightmost path efficiently. Because
the Cartesian tree for a sequence is constructed in linear time using a
stack-based algorithm, we reserve the $\mathit{lid}, \mathit{lsz}$
instead of making a edge of nodes for each nodes, which these are on the
rightmost path which is stored in the stack.  In the rotate operation of
building Cartesian tree algorithm, we maintain the $\mathit{rid},
\mathit{rsz}$ in the pop operations, and the subtree index $t$ can be
recomputed with Algorithm~\ref{alg:encode-tid} by the $\mathit{rid},
\mathit{rsz}$ and the information $\mathit{lid}, \mathit{lsz}$ on the
stack.

The Algorithm~\ref{alg:cartesian-encode-offline} is shown for offline
encoding any Cartesian tree.

\input{algorithms/alg-cartesian-encode-offline}

% Morris: remove the cache issue

There is a main issues in answering incremental ranged maximum query --
Cartesian tree encoding.  Fischer introduced the first encoding method
and the Masud~\cite{Hasan2010CacheOA} presents a new encoding method to
reduce the number of instructions.  Unfortunately all these algorithm
work in a off-line model, i.e., they assume all $n$ data are given in
advance, therefore they cannot cope with incrementally updated data in
our problem.  In addition, they require a preprocessing of time $O(n)$.
The preprocessing need more memory transfer to find the information of
the block of an input array, or read external files from disk.

However, the sparse table support range maximum query problem is more
powerful than suffix maximum value problem.

In this section, we provide a solution to make the sparse table to
support the append operation. The problem which is more powerful than
ISMQ problem is named incremental range maximum query (IRMQ).  IRMQ
support three operations.  First, a {\tt make} operation creates an
empty array $A$.  Second, a {\tt append(V) } operation appends a value
$V$ to the end of an array $A$.  Finally, a {\tt query(L, R)}
operation finds the {\em maximum} value among the $L$-th value to the
$R$-th value of an array $A$.

\iffalse

ISMQ 已知解法有二，其一使用並查集在 $O(\alpha(n))$ 解決單一操作，其二
使用樸素的稀疏表在 $O(\log n)$完成插入操作、$O(1)$ 完成詢問操作。其二，
Fischer \cite{fischer} 提出的 $\theta(n)$ -- $\theta(1)$ 無法應用在此，
其原因在於插入元素時，無法動態決定 in-block 的最大值，必須等到整個
in-block 塞滿至預設值才可解決。

在我們的應用中維護後綴最大值，
拓展其操作成為增長區間最大值查找 (\emph{incremental range maximum query}, IRMQ)，
其支援兩項操作：
\fi

Now, we provide the dynamic encoding method so that each operation is
amortized $\theta(1)$ time.  First, we need to fully recognize the
formulas encoder and decoder, so that each step in the algorithm is
$\theta(1)$.


\iffalse

接下來的幾段中，我們提供動態的編碼方式使得每一操作皆均攤 $\theta(1)$
完成。首先，我們需要充分認知編碼相互轉換的公式，藉以在算法中完成每一步
皆為 $\theta(1)$ 的要求。

在上一節提出對於任意編號 $\mathit{tid}$ 可以在 $O(n)$ 時間內得到
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$；
相反地，可以在 $\theta(1)$ 時間內逆推得到 $\mathit{tid}$，如算法
~\ref{alg:encode-tid}。透過預處理，事先將所有前綴和保存下來，在算法中
的迴圈可視為一次內存存取，使得時間複雜度 $\theta(1)$。\fi




\iffalse
根據先前的字典順序編碼，只需要維護笛卡爾樹的右鏈，實作上與堆疊結構相同。
基於 row-major 順序和遞迴定義 ~\ref{fun:LCA}，修改之前論文對於的離線編碼，
其對應方案如算法 \ref{alg:cartesian-encode-offline}。
\fi

In order to support online encoding, we use five variables to present
the state of the Cartesian tree.  The next step will insert $i$-th
elements and final stage fill $s$ number of elements.  The identity of
the current tree is $\mathit{tid}$ and the rightmost path of the
Cartesian tree is presented by two variable, stack pointer
$\mathit{Dp}$ and the stack $\mathit{D}$. The structure of state is as
follows:

\iffalse
我們定義轉移狀態由 5 個變數來決定動態笛卡爾樹的編碼，當前插入第 $i$ 個
元素，最終填充 $s$ 個元素，當前的樹編號 $\mathit{tid}$，以及笛卡爾樹的
右鏈狀態指針 $Dp$ 與其堆疊 $D$，其結構如下：
\fi

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[frame=single,caption=State of Cartesian Tree]
struct Node {
  int lsz, lid, val;
};
struct State {
  int i, s, tid, Dp;
  struct Node D[s+1];
  State(i = 0, s = n, 
          tid = C[n]-1, Dp = 0,
           D[0].val = INF)
};
\end{lstlisting}
\end{minipage}

For the online query, we choose $s=\frac{\log n}{4}$ by the Fischer's
RMQ.  In our encoding method, we initialize the $s$ number of virtual
node on the rightmost path, so the default tree label $\mathit{tid}$
is $C_s - 1$, which $C_s$ is the $s$-th Catalan number.  Following the
elements insertion, we assume the sequence of elements which is not
yet inserted are increasing.

Because of lexicographical order, the rightmost path of Cartesian tree
is belonged to the lower dimension in the row-major like.
Simultaneously, building a Cartesian tree only modify the rightmost
path. We can use the propagation characteristics to get the identity of
the tree.  Finally, we propose the difference algorithm~\ref{alg
:cartesian-encode-online} to satisfy above requirement.

\iffalse 為了解決在線詢問操作，取 $s = \frac{\log n}{4}$。根據字典順序
的編碼性質，一開始建立虛設點 $s$ 個在右鏈上，其樹編號 $\mathit{tid} =
C_s - 1$ 。隨著插入元素的增加，尚未加入的元素都預設嚴格遞減，加上根據
編碼順序，我們藉由差值來維護在線編碼 (如圖
~\ref{fig:cartesianEncoding})。根據上述的編碼想法，我們得到算法
~\ref{alg:cartesian-encode-online}。\fi

We give an example of difference algorithm in the
figure~\ref{fig:cartesianEncoding}.  Each block has $s$ number of
elements.  We will build a Cartesian tree with $s$ number of nodes to
solve in-block query.  In initialization, it assume $s$ number of
nodes on the rightmost path and the default tree identity
$\mathit{tid} = C_s - 1$.  When inserting $i$-th element, the tree
identity is $\mathit{tid}_i$, and the tree identity of the subtree $A$
is $A.\mathit{tid}$.  If the value of $(i+1)$-th element is $x$, it
will rotate onto the node $A$.  After rotation, $A$ is a left subtree
of $A$, and we can compute the identify of subtree $A$ during
rotation.  Then, $x.\mathit{tid}$ can be computed by the $s-(i+1)$
number of virtual nodes on the rightmost path and
$A.\mathit{tid}$. According to the lexicographical order, we get
$\mathit{tid}_{i+1} = \mathit{tid}_i + (x.\mathit{tid} -
A.\mathit{tid})$.

\input{algorithms/alg-cartesian-encode-online}

\begin{figure*}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-cartesian-encoding.pdf}

  \caption{An example for difference algorithm to encode Cartesian tree.}

  \label{fig:cartesianEncoding}
\end{figure*}

Finally, we do not increase the time complexity of the building
Cartesian tree algorithm because each operation is $O(1)$.  For the
in-block query, we get the identity of the Cartesian tree in $O(1)$,
and look up table to find the result.

\iffalse
最後，我們不改變原本的建立笛卡爾樹算法，便能在過程中擭得樹的編號，
每一次的 in-block 詢問只需要一次記憶體存取，得到任一操作攤銷複雜度 $\theta(1)$。
\fi
