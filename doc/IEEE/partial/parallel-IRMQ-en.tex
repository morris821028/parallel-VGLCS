\section{Query on Incrementally Updated Data}
\label{sec:parallelIRMQ}

Recall that our VGLCS algorithm has two stages.  In the first stage,
the algorithm uses incremental suffix maximum query to compute
intermediate data on every {\em column} of a two dimensional matrix.
In the second stage, the algorithm uses {\em ranged maximum query} on
the rows of the matrix from the first stage to get the final answers.
These two stages work together to find the maximum in a given
rectangle area.

The implementation for two stages have different challenges.  The first
stage is easier to parallelize because the operations on individual
columns are independent.  However, it will insert new data into the data
structure, and it still needs to answer ranged query efficiently. The
second stage does not requires insertion so it is more static, and
easier.  However, it requires working on several columns simultaneously
and synchronously.  Fortunately we have address this data synchronous
issue by computing the index table in a off-line manner, as described in
previous Section~\ref{sec:parallelIRMQ}.  As a result in this section we
will focus on how to answer ranged maximum queries efficiently on
incrementally updated data.

%% In parallel environment, the first stage of Peng's VGLCS algorithm has
%% a linear algorithm which use Fischer's sparse table instead of
%% disjoint set, and we also parallel its algorithm in theoretical $O(n /
%% p + \log n)$ time, and better performance $O(n s / p + \log n)$
%% algorithm is proposed in section~\ref{sec:parallelRMQ}.

%% Oppositely, the second stage of Peng's VGLCS algorithm has $m$ number
%% of independent data structure and run in amortized $O(n / p + 1)$
%% time.  In this section, we provide the our encoding algorithm
%% according to the parallel algorithm of building lookup table, and it
%% make row stage run in more stable amortized $O(n / p + 1)$ time.  The
%% final result is presented on table~\ref{tlb :cmp-complexity}.

\iffalse VGLCS 問題主要分成縱向和橫向兩階段，縱向處理每一列的區間極值
查找，橫向處理每一行的區間極值查找，兩者合併構成區域極值查找。在縱向方
面為數個獨立的數據結構，這部分易於平行；相反地，在橫向方面，需要共同協
作一個數據結構。綜觀這兩者的差異，縱向需要動態的後綴插入和區間查詢，而
橫向可以離線完成區間查找。在上一節中，我們提出在橫向處理的實作，若限制
上述的實作方案在單一處理器上，時間複雜度的瓶頸在於縱向的動態更新與查找。
在這個章節中，我們提出支持動態插入和區間查找的數據結構，最後的成果如表
\ref{tlb:cmp-complexity}。
\fi

% not here, somewhere else
%\input{./tables/tlb-cmp-complexity.tex}

\subsection{Build Lookup Table}

There are two main issues in answering ranged maximum query --
Cartesian tree encoding and cache performance.  Fischer introduced the
first encoding method and the Masud~\cite{Hasan2010CacheOA} presents a
new encoding method to reduce the number of instructions and sorting
step to reduce cache miss.  Unfortunately all these algorithm work in
a off-line model, i.e., they assume all $n$ data are given in advance,
therefore they cannot cope with incrementally updated data in our
problem.  In addition, they require a preprocessing of time $O(n)$,
which is difficult to parallelize.

%% In VGLCS problem, we could not use sorting to improve cache miss
%% because the number of elements and queries are similar.  We proposed
%% the parallel algorithm for building lookup table by our encode method.

\subsubsection{Cartesian Tree Encoding}

Our Cartesian tree encoding method lists {\em all} binary search trees
in {\em lexicographical order} and label them from $0$ to the $n$-th
Catalan number minus 1.  The lexicographical order among binary search
trees of the {\em same} number of nodes is defined {\em recursively}
as follows.  A binary tree $a$ appears {\em before} another binary if
$a$ has more nodes than $b$ in the left subtree, or $a$ and $b$ has
the same number of nodes in the left subtree, and $a$'s left subtree
appears before $b$'s left subtree in lexicographical order, or $a$ and
$b$ has the same left subtree, and $a$'s right subtree appears before
$b$'s right subtree in lexicographical order.
Figure~\ref{fig:labelingBST} shows our labelling of binary search tree
for 1, 2 and 3 nodes.

\iffalse
關於在線操作，我們從 Fischer \cite{fischer} 和 Masud \cite{masud} 的研究中，
分別得到關於笛卡爾的編碼與快取改善的技術，而這些技術都著手於離線操作，
即一開始給訂 $n$ 個元素值，並且在 $O(n)$ 時間內編碼一棵樹；
接著，再利用前處理的查找表完成極值查找。

關於快取效能，因詢問次數與元素個數相當，
故無法像 Masud \cite{masud} 的研究藉由排序編碼以減少快取未中的問題，
只能依賴數據本身的分佈和編碼之間的關聯來減少快取未中的情況。

從上述幾點觀點出發，我們提出動態的編碼方式。
算法採用字典順序的方式編碼一棵樹，優先增長左子樹，
當相同左子樹時，增長右子樹的方式進行編號，其編碼方式如圖 \ref{fig:lablingBST}。
\fi

\begin{figure}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-bst-encoding.pdf}
  \caption{The labelling of binary search trees}
  \label{fig:labelingBST}
\end{figure}

For ease of discussion we define several notations.  Let
$\mathit{tid}$ be the index of the search tree in our encoding, so
$\mathit{tid}$ is between 0 and $s - 1$, where $s$ is the number of
search trees.  Let $\mathit{LCA}(s, \mathit{tid}, p, q)$ denote the
{\em lowest common ancestor} of the node $p$ and $q$ within a binary
search tree with $s$ nodes label $\mathit{tid}$.  For exmaple,
$\mathit{LCA}(3, 2, 0, 2) = 1$ from Figure~\ref{fig:labelingBST}.
Also we consider the tree of $s$ nodes with label $\mathit{tid}$, and
let $\mathit{lsz}$ denote the size of the left subtree, $\mathit{rsz}$
denote the size of the right subtree, $\mathit{lid}$ be the label of
its left subtree, and $\mathit{rid}$ be the label of its right
subtree.  With these notations we can define the lowest common
ancesstor recursively as in Equation~\ref{fun:LCA1} when $l_s \le
  p \le q < n$.  Other cases are defined in Equation~\ref{fun:LCA2}. 

\input{./formulas/fun-LCA.tex}

% need a formal proof here.

In order to store all binary search trees, the space complexity is in
Equation~\ref{eq:space}, and the time complexity of parallel
algorithm~\ref{alg:parallel-LCA} is in
Equation~\ref{eq:parallel-time}.


\begin{equation} \label{eq:space}
\theta\left(\frac{s^2}{s+1} \binom{2s}{s}\right) =
\theta\left(n\right)
\end{equation}


\begin{equation} \label{eq:parallel-time}
\theta\left(\frac{s^3}{s+1} \binom{2s}{s} \bigg/ p + s^2 \right)
\end{equation}.

\iffalse

為記錄所有的二元搜尋樹的 LCA，空間消耗 $\theta\left(\frac{s^2}{s+1}
\binom{2s}{s}\right) = \theta\left(n\right)$；其平行算法
\ref{alg:parallel-LCA} 的時間複雜度如下：

\begin{equation}
\theta\left(\frac{s^3}{s+1} \binom{2s}{s} \bigg/ p + s^2 \right)
\end{equation}.
\fi

\input{algorithms/alg-parallel-LCA.tex}

\subsection{Dynamic Encoding Cartesian Tree}

Recall that in the VGLCS problem, there are three intuitive solutions
for ISMQ.  The first one uses naive disjoint set which uses amortized
$O(\alpha(n))$ for each query, or advance variant disjoint set --
incremental tree set union~\cite{Gabow1983ALA} uses amortized $O(1)$
for each query.  The second one uses sparse table which uses $O(\log
n)$ time to append a new value to the tail of array and $O(1)$ time to
response a query.  The third one is the binary indexed tree which used
$O(\log n)$ time for each operation.  Even if the amortized complexity
of the algorithm is $O(\alpha(n))$ or $O(1)$, the algorithm incurs
inefficient synchronizations in the parallel environment. Therefore,
the last two data structure is more suitable than the first one.

About the sparse table, Fischer provide the $O(n)$ -- $O(1)$
algorithm.  However, the sparse table support range maximum query
problem is more powerful than suffix maximum value problem.  In this
section, we provide a solution to make the sparse table to support the
append operation. The problem which is more powerful than ISMQ problem
is named incremental range maximum query (IRMQ).  IRMQ support three
operations.  First, a {\tt make} operation creates an empty array $A$.
Second, a {\tt append(V) } operation appends a value $V$ to the end of
an array $A$.  Finally, a {\tt query(L, R)} operation finds the {\em
  maximum} value among the $L$-th value to the $R$-th value of an
array $A$.

\iffalse

ISMQ 已知解法有二，其一使用並查集在 $O(\alpha(n))$ 解決單一操作，其二
使用樸素的稀疏表在 $O(\log n)$完成插入操作、$O(1)$ 完成詢問操作。其二，
Fischer \cite{fischer} 提出的 $\theta(n)$ -- $\theta(1)$ 無法應用在此，
其原因在於插入元素時，無法動態決定 in-block 的最大值，必須等到整個
in-block 塞滿至預設值才可解決。

在我們的應用中維護後綴最大值，
拓展其操作成為增長區間最大值查找 (\emph{incremental range maximum query}, IRMQ)，
其支援兩項操作：
\fi

Now, we provide the dynamic encoding method so that each operation is
amortized $\theta(1)$ time.  First, we need to fully recognize the
formulas encoder and decoder, so that each step in the algorithm is
$\theta(1)$.

In the previous section, for any identify $\mathit{tid}$ of BST, we
can get $\langle\mathit{lsz}, \mathit{lid}, \mathit{rsz},
\mathit{rid}\rangle$ in $O(n)$ time.  Oppositely, we get
$\mathit{tid}$ from $\langle\mathit{lsz}, \mathit{lid}, \mathit{rsz},
\mathit{rid}\rangle$ in $\theta(1)$.  The algorithm
\ref{alg:encode-tid} show the inverse function run in $\theta(1)$.  By
the pre-processing, all the prefix sum store in the memory, so the for
loop can be replaced by one time memory access in the algorithm
\ref{alg:encode-tid}.

\iffalse

接下來的幾段中，我們提供動態的編碼方式使得每一操作皆均攤 $\theta(1)$
完成。首先，我們需要充分認知編碼相互轉換的公式，藉以在算法中完成每一步
皆為 $\theta(1)$ 的要求。

在上一節提出對於任意編號 $\mathit{tid}$ 可以在 $O(n)$ 時間內得到
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$；
相反地，可以在 $\theta(1)$ 時間內逆推得到 $\mathit{tid}$，如算法
~\ref{alg:encode-tid}。透過預處理，事先將所有前綴和保存下來，在算法中
的迴圈可視為一次內存存取，使得時間複雜度 $\theta(1)$。\fi

\input{algorithms/alg-encode-tid}

By the recursive formula, we could implement without storing full
Cartesian tree.  The rightmost path is consisted of the root, the
right child of the root, the right child of the right child of the
root, ..., and so on.  We maintain the rightmost path of a Cartesian
tree as a stack.  The algorithm \ref{alg :cartesian-encode-offline} is
shown for offline encoding any Cartesian tree.

\iffalse
根據先前的字典順序編碼，只需要維護笛卡爾樹的右鏈，實作上與堆疊結構相同。
基於 row-major 順序和遞迴定義 ~\ref{fun:LCA}，修改之前論文對於的離線編碼，
其對應方案如算法 \ref{alg:cartesian-encode-offline}。
\fi

\input{algorithms/alg-cartesian-encode-offline}

In order to support online encoding, we use five variables to present
the state of the Cartesian tree.  The next step will insert $i$-th
elements and final stage fill $s$ number of elements.  The identity of
the current tree is $\mathit{tid}$ and the rightmost path of the
Cartesian tree is presented by two variable, stack pointer
$\mathit{Dp}$ and the stack $\mathit{D}$. The structure of state is as
follows:

\iffalse
我們定義轉移狀態由 5 個變數來決定動態笛卡爾樹的編碼，當前插入第 $i$ 個
元素，最終填充 $s$ 個元素，當前的樹編號 $\mathit{tid}$，以及笛卡爾樹的
右鏈狀態指針 $Dp$ 與其堆疊 $D$，其結構如下：
\fi

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[frame=single,caption=State of Cartesian Tree]
struct Node {
  int lsz, lid, val;
};
struct State {
  int i, s, tid, Dp;
  struct Node D[s+1];
  State(i = 0, s = n, 
          tid = C[n]-1, Dp = 0,
           D[0].val = INF)
};
\end{lstlisting}
\end{minipage}

For the online query, we choose $s=\frac{\log n}{4}$ by the Fischer's
RMQ.  In our encoding method, we initialize the $s$ number of virtual
node on the rightmost path, so the default tree label $\mathit{tid}$
is $C_s - 1$, which $C_s$ is the $s$-th Catalan number.  Following the
elements insertion, we assume the sequence of elements which is not
yet inserted are increasing.

Because of lexicographical order, the rightmost path of Cartesian tree
is belonged to the lower dimension in the row-major like.
Simultaneously, building a Cartesian tree only modify the rightmost
path. We can use the propagation characteristics to get the identity of
the tree.  Finally, we propose the difference algorithm~\ref{alg
:cartesian-encode-online} to satisfy above requirement.

\iffalse 為了解決在線詢問操作，取 $s = \frac{\log n}{4}$。根據字典順序
的編碼性質，一開始建立虛設點 $s$ 個在右鏈上，其樹編號 $\mathit{tid} =
C_s - 1$ 。隨著插入元素的增加，尚未加入的元素都預設嚴格遞減，加上根據
編碼順序，我們藉由差值來維護在線編碼 (如圖
~\ref{fig:cartesianEncoding})。根據上述的編碼想法，我們得到算法
~\ref{alg:cartesian-encode-online}。\fi

We give an example of difference algorithm in the
figure~\ref{fig:cartesianEncoding}.  Each block has $s$ number of
elements.  We will build a Cartesian tree with $s$ number of nodes to
solve in-block query.  In initialization, it assume $s$ number of
nodes on the rightmost path and the default tree identity
$\mathit{tid} = C_s - 1$.  When inserting $i$-th element, the tree
identity is $\mathit{tid}_i$, and the tree identity of the subtree $A$
is $A.\mathit{tid}$.  If the value of $(i+1)$-th element is $x$, it
will rotate onto the node $A$.  After rotation, $A$ is a left subtree
of $A$, and we can compute the identify of subtree $A$ during
rotation.  Then, $x.\mathit{tid}$ can be computed by the $s-(i+1)$
number of virtual nodes on the rightmost path and
$A.\mathit{tid}$. According to the lexicographical order, we get
$\mathit{tid}_{i+1} = \mathit{tid}_i + (x.\mathit{tid} -
A.\mathit{tid})$.

\input{algorithms/alg-cartesian-encode-online}

\begin{figure*}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-cartesian-encoding.pdf}

  \caption{An example for difference algorithm to encode Cartesian tree.}

  \label{fig:cartesianEncoding}
\end{figure*}

Finally, we do not increase the time complexity of the building
Cartesian tree algorithm because each operation is $O(1)$.  For the
in-block query, we get the identity of the Cartesian tree in $O(1)$,
and look up table to find the result.

\iffalse
最後，我們不改變原本的建立笛卡爾樹算法，便能在過程中擭得樹的編號，
每一次的 in-block 詢問只需要一次記憶體存取，得到任一操作攤銷複雜度 $\theta(1)$。
\fi
