\section{Query on Incrementally Added Data} \label{sec:QIUD}

This section describes our approach to address the challenges in the
first stage of Algorithm~\ref{alg:parallel-VGLCS}, where we compute
the suffix maximum on every {\em column} of $V$ while new data are
added incrementally.  Here we generalize our technique so that we can
also answer incremental {\em ranged} maximum on incrementally added
data, so that our technique can be applied to other cases that require
ranged maximum query.

% not here, somewhere else
%\input{./tables/tlb-cmp-complexity.tex}

\subsection{Build Least Common Ancestor Table}

Recall from the discussion of Cartesian tree in
Section~\ref{sec:parallelRMQ} that finding the {\em least common
  ancestor} is important for answering ranged maximum queries.  Here
we need to address two issues -- how to map a binary tree into its
{\em Catalan index} and how to find the least common ancestor of two
nodes in a given tree.

%% In VGLCS problem, we could not use sorting to improve cache miss
%% because the number of elements and queries are similar.  

\subsubsection{Cartesian Tree Mapping}

Our Cartesian tree mapping lists {\em all} binary search trees in {\em
  lexicographical order} and label them from $0$ to the $n$-th Catalan
number minus 1.  The lexicographical order among binary search trees
of the {\em same} number of nodes is defined {\em recursively} as
follows.  A binary tree $a$ appears {\em before} another binary if $a$
has more nodes than $b$ in the left subtree, or $a$ and $b$ has the
same number of nodes in the left subtree, and $a$'s left subtree
appears before $b$'s left subtree in lexicographical order, or $a$ and
$b$ has the same left subtree, and $a$'s right subtree appears before
$b$'s right subtree in lexicographical order.
Figure~\ref{fig:labelingBST} shows our Catalan indexing of binary
search tree for 1, 2 and 3 nodes.

\begin{figure}[!thb]
  \centering
  \includegraphics[width=\linewidth]{\GraphicPath/fig-bst-encoding.pdf}
  \caption{The labeling of binary search trees}
  \label{fig:labelingBST}
\end{figure}

\subsubsection{Least Common Ancestor}

% lowest common ancestor -> least common ancestor?

We also need to determine the least common ancestor {\em efficiently}
for answering ranged maximum queries on incrementally added data.  Let
$t$ be the Catalan index of the search tree, so $t$ is between 0 and
$s - 1$, where $s$ is the number of search trees.  Let ${\cal A}(s, t,
p, q)$ denote the {\em least common ancestor} of the node $p$ and $q$
within a binary search tree with $s$ nodes and Catalan index $t$.  For
example, ${\cal A}(3, 2, 0, 2) = 1$ from Figure~\ref{fig:labelingBST}.
Also we consider the tree of $s$ nodes with label $t$, and let $s_l$
denote the size of the left subtree, $s_r$ denote the size of the
right subtree, $t_l$ be the Catalan index of its left subtree, and
$t_r$ be the Catalan index of its right subtree.  With these notations
we can define the least common ancestor {\em recursively} as in
Equation~\ref{fun:LCA1} when $s_l \le p \le q < n$.  Other cases are
defined in Equation~\ref{fun:LCA2}.  A Pseudo code is given in
Algorithm~\ref{alg:parallel-LCA}.

\input{\FormulaPath/fun-LCA.tex}

\input{\AlgoPath/alg-parallel-LCA-2e}

We first analyze the space complexity of
Algorithm~\ref{alg:parallel-LCA}.  The lookup table records the all
the binary tree of sizes from 1 to $s$.  When tree size is $m$, the
number of different binary trees is the $n$-th Catalan number $C_m$,
which is $\frac{1}{m+1}\binom{2m}{m} = O(\frac{4^m}{m^{1.5}})$.  For
each binary tree of size $m$, we store the least common ancestor of
{\em every} pair of nodes into the table, so the size of the table is
$O(m^2)$.  Therefore, the space complexity is $O(s \times
\frac{1}{s+1}\binom{2s}{s} \times s^2)$, where $s$ is the number of
elements in a block.  When we set $s$ to $\frac{\log n}{4}$, the space
complexity is $O(\sqrt{n} \log ^{1.5} n)$.  Note that the query will
be on the tree size of $s$ {\em only}.  However, we do need the space
for tables of {\em smaller} tree sizes as intermediate data to compute
the table of tree size $s$.  Also since the number of operations in
Equation~\ref{fun:LCA1} and \ref{fun:LCA2} is a constant, the time
complexity is also $O(\sqrt{n} \log ^{1.5} n)$ when we set $s$ to
$\frac{\log n}{4}$.

We now analyze the time complexity of the parallel version of
Algorithm~\ref{alg:parallel-LCA}.  As described earlier, the
sequential time complexity of Algorithm~\ref{alg:parallel-LCA} is
$O(\frac{s^3}{s+1} \binom{2s}{s})$.  We observe that the computation
of the $C_m$ trees of size $m$ are independent, hence can be done in
parallel.  However, the time to find the sizes and ids of subtrees (in
line 4) is $O(m)$ for a tree of size $m$.  Since both line 4 and 5 are
in the same loop body, it is not necessary to parallel line 4 since
line 5 will dominate the time of the loop body.  As a result we can
only parallelize the double loops in line 2 and 3 in
Algorithm~\ref{alg:parallel-LCA}, and the time complexity of our
parallel algorithm is $O(\frac{s^3}{s+1} \binom{2s}{s} / p + s^2) =
O(\sqrt{n} (\log ^{1.5} n) / p + \log^2 n )$, where $p$ is the number
of processors.

%% % how to compute subtree information from t

%% Note that in line 4 of Algorithm~\ref{alg:parallel-LCA}, when given
%% the tree id $t$, we need to compute the sizes and ids of the left and
%% right subtrees in our encoding.  We can do this in $O(n)$ time, where
%% $n$ is the number of tree nodes.

\subsection{Catalan Index Computation}

Note that Algorithm~\ref{alg:parallel-LCA} requires Catalan index $t$,
so we need to determine $t$ efficiently when given a block of data.
There are two possible approaches -- build the tree or keep only the
rightmost path.

% how to compute t from tree data structure

\subsubsection{Build the Tree}

In order to find the Catalan index of the block, we can build a
Cartesian tree corresponding to the elements of the block, and then
find the index of the Cartesian tree.  That is, we build the tree and
compute it from the the sizes and ids of the left and right subtrees.
This require a recursive traversal on the tree and has a $O(n)$ time
complexity, where $n$ is the number of tree nodes.  The conversion is
as in Equation~\ref{fun:tid}.  Recall that $s_l$ denotes the size of
the left subtree, $s_r$ denotes the size of the right subtree, $t_l$
is the Catalan index of the left subtree, and $t_r$ is the Catalan
index of the right subtree.  Also note that we use ${\cal C}_i$ to
  denote the Catalan number of tree of size $i$.

% \input{algorithms/alg-encode-tid}

\input{\FormulaPath/fun-tid}

We can further optimize Equation~\ref{fun:tid} by pre-computing the
{\em prefix sum} of the Catalan number products.  Then we store these
sums in memory, so that we can use them directly, instead of
recomputing them as in Equation~\ref{fun:tid}.  That is, we can
pre-compute these summation, and replace the summation in
Equation~\ref{fun:tid} with a table lookup.

% how to compute t with rightmost path of the tree

\subsubsection{Keep the Rightmost Path}

The previous computation of Catalan index requires building the tree
to obtain subtree information, and may not be efficient.  We propose a
method that determines the Catalan index by keeps only the {\em
  rightmost path} in a {\em stack} without building the entire tree.
This technique is similar to the {\em compressed Cartesian tree} in
Section~\ref{sec:cct}.  After knowing the Catalan index $t$ we can
compute LCA and answer queries with Algorithm~\ref{alg:parallel-LCA}.

We compute the Catalan index $t$ efficiently by the maintaining its
{\em rightmost path}.  The Cartesian tree for a sequence of data can
be constructed in linear time using a {\em stack} as follows.  The
stack maintains the Catalan indexes and sizes of every left subtree
along the right most path.  That is, we will {\em not} build these
left subtrees, but only keep their Catalan indexes and sizes.

\begin{figure}[!thb]
  \centering
  \includegraphics[width=0.6\linewidth]{\GraphicPath/fig-cartesian-encoding-static.pdf}
  \caption{Compute Catalan index for a tree.  $A_l$ and $B_l$ denote
    the left subtrees of $A$ and $B$ respectively.}
  \label{fig:fig-cartesian-encoding-static}
\end{figure}

The pseudo code of this Catalan index computation is in
Algorithm~\ref{alg:cartesian-encode-offline}.  This algorithm computes
the Catalan index for a given block of data.  Note that each node of
the stack $D$ has three members -- $v$ as the data, $s$ as the size of
its subtree, and $t$ as the index of its left subtree.  We also use a
pointer $p$ to point to the top of the stack.  In the first double
loop the outer loop goes through every input and the inner loop
inserts a data at the {\em end} of the right most path, which is at
the top of the stack $D[p]$, and traverse towards the root by popping
any {\em smaller} data out of the stack $D$.  When we rotate nodes
along the rightmost path to update the Cartesian tree, we compute the
new {\em index} $t$ and size $s$ of the new left subtree whenever the
newly inserted data replaces it.  As a result the new Catalan index
$t$ can be recomputed with Equation~\ref{fun:tid} by the indexes and
sizes of the left and right subtrees in the stack.  Please refer to
the first while loop of Algorithm~\ref{alg:cartesian-encode-offline}
and Figure~\ref{fig:fig-cartesian-encoding-static} for an
illustration.  Note that $A_l$ and $B_l$ denote the left subtrees of
$A$ and $B$ respectively.  After popping all smaller data in the stack
the while loop stops and the size, index, and input are pushed into
the new top of stack.  Finally we pop all data out of the stack and
compute the Catalan index for the entire block.

Algorithm~\ref{alg:cartesian-encode-offline} can compute any Catalan
index for Cartesian trees with the entire block of data and the block
size.  The algorithm runs in $O(s)$ time since an element is
pushed/popped at most {\em once}.

\input{\AlgoPath/alg-cartesian-encode-offline-2e}

\subsection{Dynamic Catalan Index Computation}

Several encoding methods were proposed for indexing Cartesian search
trees.  Fischer~\cite{Fischer2006TheoreticalAP} introduced the first
encoding method and Masud~\cite{Hasan2010CacheOA} presents a new
encoding method to reduce the number of instructions.  Unfortunately
all these algorithm work in an off-line model, i.e., they assume all
data are given in advance, and cannot cope with incrementally added
data.  In addition, they require a preprocessing of time $O(n)$, where
$n$ is the number of data.  The preprocessing need more memory
transfer to find the information of the block of an input array, or
read external files from disk.

We can generalize our Catalan index computation technique for
incrementally added data by {\em normalization}.  Suppose we want to
encode a series of Cartesian search trees of increasing sizes up to
$n$, we can append a path of $n-i$ {\em right-child-only} nodes to the
right most path of the existing tree of size $i$, so that the total
number remains $n$.  That is, when the computation starts whiteout any
existing tree nodes we will use a path of $n$ right-child-only nodes.
Please refer to the figure on the left of
Figure~\ref{fig:cartesianEncoding} for an illustration.  After we have
added $i$ nodes, we will have a a path of $n - i$ right-child-only
nodes attached to the right most path, as illustrated by the figure in
the left of Figure~\ref{fig:cartesianEncoding}.  For ease of
explanation we will refer to this added path as the {\em virtual
  path}.

\begin{figure*}[!thb]
  \centering \subfigure[Initiation $t_{{\it root}_0}= C_n - 1$]{
    \includegraphics[width=0.3\linewidth]{\GraphicPath/fig-cartesian-encoding.pdf}
    \label{fig:cartesianEncoding-init}
  } \subfigure[$t_{{\it root}_i}$]{
    \includegraphics[width=0.3\linewidth]{\GraphicPath/fig-cartesian-encoding-before.pdf}
    \label{fig:cartesianEncoding-before}
  } \subfigure[$t_{{\it root}_{i+1}} = t_{{\it root}_i} + t_x - t_A$]{
    \includegraphics[width=0.3\linewidth]{\GraphicPath/fig-cartesian-encoding-after.pdf}
    \label{fig:cartesianEncoding-after}
  }
  \caption{An example for difference algorithm to encode Cartesian tree.}
  \label{fig:cartesianEncoding}
\end{figure*}

There are two advantages of this tree normalization.  First, this tree
normalization simplifies the computation of Catalan index, as we will
explain later.  That is, we can update the Catalan index with ease
whenever we insert a new data.  Second, one can image this
normalization as adding increasing larger data to the end of a data
block, so that the interval maximum on any existing tree in the series
will not be affected.  That is, we can {\em dynamically} maintain a
lookup table to obtain the maximum value in a range, so as to answer a
ranged query by this Cartesian tree encoding.

%% Now, we provide the dynamic encoding method so that each operation is
%% amortized $O(1)$ time.

The dynamic Catalan index computation with tree normalization works as
follows.  We will remember the current index of the tree (as $t^*$),
and a stack of the right most path of the current tree, as $D$ in
Algorithm~\ref{alg:cartesian-encode-offline}.  Then we will {\em
  update} these information once we add a new data $x$ into the tree,
by calling Algorithm~\ref{alg:cartesian-encode-online}, which is based
on Algorithm~\ref{alg:parallel-LCA} and Equation~\ref{fun:tid}.  At
any given time, i.e., for any $i$ where $i$ is the index of the data,
we we can compute the Catalan index of the current tree, which has $i$
nodes, and use it to answer a ranged maximum query.

For ease of notation we use we use $t$ and $s$ to denote the index and
the size of the tree {\em without} the virtual path.  This is similar
to Algorithm~\ref{alg:cartesian-encode-offline}.  We also use $t'$ and
$s'$ to maintain the index and size of the tree {\em with} the virtual
path, as indicated by the part enclosed by the red dotted line in the
middle of Figure~\ref{fig:cartesianEncoding}.

Algorithm~\ref{alg:cartesian-encode-online} first initializes $s$ and
$t$ as in Algorithm~\ref{alg:cartesian-encode-offline}, since it will
work from the end of the rightmost path and start with an empty tree.
Then the algorithm initializes $s'$ to $n - i$ since we will append
the a virtual path of length $n - i$ to the end of the rightmost path.
Consequently $t'$ is the ${\cal C}_{s'} - 1$ since it has the largest
Catalan index.

Algorithm~\ref{alg:cartesian-encode-online} then inserts the $i$-th
element, $x$, in two stages.  The first stage is to pop the elements
smaller than $x$ from the stack $D$.  Recall that we maintain the
index of the current tree as $t$ and the rightmost path of the
Cartesian tree as two variables -- stack pointer $p$ and a stack $D$.
Note that $t$ and $s$ are the index and size of the last subtree {\em
  without} the virtual path.  Consequently as we popped smaller
elements from the stack and update $s$ and $t$ just as in
Algorithm~\ref{alg:cartesian-encode-online}.  The update on $s'$ and
$t'$ is similar, but it assumes that there is a virtual path of $n -
s'$ right-child-only nodes to the right of the rightmost path.  Please
refer to the inner loop of Algorithm~\ref{alg:cartesian-encode-online}
and Figure~\ref{fig:cartesianEncoding}.

\input{\AlgoPath/alg-cartesian-encode-online-2e}

Now we are ready to update the stack and the Catalan index $t^*$.  The
new top of stack is now $x$, with left subtree of size $s$ and index
$t$, so we push them into the stack.  Please refer to the right
figures of Figure~\ref{fig:cartesianEncoding}.  Next we update the
overall Catalan index $t^*$.  After we popped all elements smaller
than $x$, they should be inserted to the left of the $x$.  Please
compare the middle and right figures in
Figure~\ref{fig:cartesianEncoding}.  The only difference between the
the middle and right figures of Figure~\ref{fig:cartesianEncoding} is
the area enclosed by the red dotted line.  If we compute the
difference between the index of the two dotted line area, we can {\em
  patch} the overall $t^*$ into the correct value, since our encoding
considers left subtree {\em before} right subtree.  Since the
difference is $t' - {\cal T}(s, t, s - i, {\cal C}_{s-i} - 1)$, the
new $t^*$ is the old value of $t^*$, plus $t' - {\cal T}(s, t, s - i,
{\cal C}_{s-i} - 1)$.

Note that Algorithm~\ref{alg:cartesian-encode-online} does {\em not}
increase the amrtized time complexity to compute teh Catalan index,
even when we dynamically add data into the tree.  As described
earleir, the time complexity of the static index computation
(Algorithm~\ref{alg:cartesian-encode-online}) is $O(n)$ because each
element is popped exactly once.  Similarly the total cost of calling
Algorithm~\ref{alg:cartesian-encode-online} $n$ times is also $O(n)$,
since each operation within the loop is $O(1)$.  As a result the
amortized cost for an in-block query, including the computation of
tree index, is also $O(1)$.

\iffalse
最後，我們不改變原本的建立笛卡爾樹算法，便能在過程中擭得樹的編號，
每一次的 in-block 詢問只需要一次記憶體存取，得到任一操作攤銷複雜度 $\theta(1)$。
\fi
