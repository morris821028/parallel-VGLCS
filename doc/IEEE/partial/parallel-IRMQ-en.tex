\section{Incremental Range Maximum Query}

In the VGLCS problem, we divide our algorithm into two stage, row and
column stage.  In the row stage, it maintains $m$ number of the data
structure to support ISMQ problem.  After row stage, the column stage
uses one ISMQ data structure to answer each query.

In parallel environment, the column stage has a linear algorithm which
use Fischer's sparse table instead of disjoint set, and we also
parallel its algorithm in theoretical $O(n / p + \log n)$ time, and
better performance algorithm in $O(n s / p + \log n)$ in section
~\ref{sec:parallelRMQ}.  Oppositely, the row stage has $m$ number of
independent data structure and run in amortized $O(n / p + 1)$ time.
In this section, we provide the new data structure to make row stage
run in more stable amortized $O(n / p + 1)$ time.   The final result
is presented on table ~\ref{tlb:cmp-complexity}.

\iffalse
VGLCS 問題主要分成縱向和橫向兩階段，縱向處理每一列的區間極值查找，橫向處理每一行的區間極值查找，
兩者合併構成區域極值查找。在縱向方面為數個獨立的數據結構，這部分易於平行；
相反地，在橫向方面，需要共同協作一個數據結構。
綜觀這兩者的差異，縱向需要動態的後綴插入和區間查詢，而橫向可以離線完成區間查找。
在上一節中，我們提出在橫向處理的實作，若限制上述的實作方案在單一處理器上，
時間複雜度的瓶頸在於縱向的動態更新與查找。

在這個章節中，我們提出支持動態插入和區間查找的數據結構，最後的成果如表 \ref{tlb:cmp-complexity}。
\fi


\input{./tables/tlb-cmp-complexity.tex}

\subsection{Build Look-up Table}

We have two main subjects: Cartesian tree encoding and cache
performance.  Fischer introduced the first encoding method and the
Masud \cite{Hasan2010CacheOA} presents the new encoding method and
processing step to reduce the number of instructions.  However, most
of them focus on the offline algorithm.  It means that there are given
$n$ elements and then has $m$ queries.  During any queries, the $n$
elements will not be modified by any operation.

We could not use sorting to improve cache miss because the number of
elements and queries are similar.  However, we can still improve the
cache miss by the special encoding method according to value
distribution.

In our application, we provide the online encoding algorithm.  We list
all binary search trees by lexicographical order and label them from
$0$ to $n$-th Catalan number.  The lexicographical order for binary
search tree is defined by the left subtree high priority and then
right subtree.  The figure \ref{fig:labelingBST} shows label of binary
search tree for the $n=1,2,3$ number of nodes.

\iffalse
關於在線操作，我們從 Fischer \cite{fischer} 和 Masud \cite{masud} 的研究中，
分別得到關於笛卡爾的編碼與快取改善的技術，而這些技術都著手於離線操作，
即一開始給訂 $n$ 個元素值，並且在 $O(n)$ 時間內編碼一棵樹；
接著，再利用前處理的查找表完成極值查找。

關於快取效能，因詢問次數與元素個數相當，
故無法像 Masud \cite{masud} 的研究藉由排序編碼以減少快取未中的問題，
只能依賴數據本身的分佈和編碼之間的關聯來減少快取未中的情況。

從上述幾點觀點出發，我們提出動態的編碼方式。
算法採用字典順序的方式編碼一棵樹，優先增長左子樹，
當相同左子樹時，增長右子樹的方式進行編號，其編碼方式如圖 \ref{fig:lablingBST}。
\fi

\begin{figure}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-bst-encoding.pdf}
  \caption{The label of each binary search tree}
  \label{fig:labelingBST}
\end{figure}

For the $s$ nodes binary search tree, we label node from $0$ to $s-1$
and the identify $\mathit{tid}$.  We define $\mathit{LCA}(s,
\mathit{tid}, p, q)$ as the lowest common ancestor of the node $p$ and
$q$ on a binary search tree which has $s$ nodes and labeling
$\mathit{tid}$, such as $\mathit{LCA}(3, 2, 0, 2) = 1$.

We define four variable
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$,
which $\mathit{lsz}$ is the size of the left subtree, $\mathit{rsz}$
is the size of the right subtree, $\mathit{lid}$ is the identify of
the left subtree, and $\mathit{rid}$ is the identify of the right
subtree.  These four variables
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$ is
decided by the identify of binary search tree $\mathit{tid}$ in
$O(s)$.  Finally, the formula \ref{fun:LCA} is shown for the lowest
common ancestor.

\iffalse
對於 $s$ 個節點的二元搜尋樹，其權重從 $0$ 開始至 $s-1$、樹編號為 $\mathit{tid}$。
定義 $\mathit{LCA}(s, \mathit{tid}, p, q)$ 為其樹上兩點 $p$ 和 $q$ 的最小共同祖先，
如 $\mathit{LCA}(3, 2, 0, 2) = 1$。

定義四個變數 $\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$ 分別為左右子樹的大小和其編號，
這四個變數根據指定的 $\mathit{tid}$ 可在 $O(n)$ 時間內得到。
最後，推導得遞迴公式 ~\ref{fun:LCA}。 
\fi

\input{./formulas/fun-LCA.tex}

In order to store all binary search trees, the space complexity is 

\begin{equation}
\theta\left(\frac{s^2}{s+1} \binom{2s}{s}\right) = \theta\left(n\right)
\end{equation}

, and the time complexity of parallel algorithm \ref{alg:parallel-LCA}
is

\begin{equation}
\theta\left(\frac{s^3}{s+1} \binom{2s}{s} \bigg/ p + s^2 \right)
\end{equation}.

\iffalse
為記錄所有的二元搜尋樹的 LCA，空間消耗 $\theta\left(\frac{s^2}{s+1} \binom{2s}{s}\right) = \theta\left(n\right)$；
其平行算法 \ref{alg:parallel-LCA} 的時間複雜度如下：

\begin{equation}
\theta\left(\frac{s^3}{s+1} \binom{2s}{s} \bigg/ p + s^2 \right)
\end{equation}.
\fi

\input{algorithms/alg-parallel-LCA.tex}

\subsection{Dynamic Cartesian Tree}

There are three intuitive solutions for ISMQ.  The first one uses
disjoint set which uses $O(\alpha(n))$ for each query.  The second one
uses sparse table which uses $O(\log n)$ time to append a new value to
the tail of array and $O(1)$ time to response a query.  The third one
is the binary indexed tree which used $O(\log n)$ time for each
operation.

In the sparse table, Fischer provide the $\theta(n)$ -- $\theta(1)$
could not support the append operation.  However, the sparse table
support RMQ problem is more powerful than suffix maximum value
problem.  In this section, we provide a solution to make the sparse
table to support the append operation.  The problem which is more
powerful than ISQM problem is named incremental range maximum query
(IRMQ).  IRMQ support two kinds of operation as follows:

\iffalse
ISMQ 已知解法有二，其一使用並查集在 $O(\alpha(n))$ 解決單一操作，
其二使用樸素的稀疏表在 $O(\log n)$完成插入操作、$O(1)$ 完成詢問操作。
其二，Fischer \cite{fischer} 提出的 $\theta(n)$ -- $\theta(1)$ 無法應用在此，
其原因在於插入元素時，無法動態決定 in-block 的最大值，必須等到整個 in-block 塞滿至預設值才可解決。

在我們的應用中維護後綴最大值，
拓展其操作成為增長區間最大值查找 (\emph{incremental range maximum query}, IRMQ)，
其支援兩項操作：
\fi

\begin{itemize}
  \item 
  	\texttt{Append V} : Append a new value $V$ to the tail of array.

  \item
    \texttt{Query L R} : Query the maximum value between position $L$
and $R$. 

\end{itemize}

Now, we provide the dynamic encoding method so that each operation is
amortized $\theta(1)$ time.  First, we need to fully recognize the
formulas encoder and decoder, so that each step in the algorithm is
$\theta(1)$.

In the previous section, for any identify $\mathit{tid}$ of BST, we
can get
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$ in
$O(n)$ time.  Oppositely, we get $\mathit{tid}$ from
$\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$ in
$\theta(1)$.  The algorithm \ref{alg:encode-tid} show the inverse
function run in $\theta(1)$.  By the pre-processing, all the prefix
sum store in the memory, so the for loop can be replaced by one time
memory access in the algorithm \ref{alg:encode-tid}.

\iffalse
接下來的幾段中，我們提供動態的編碼方式使得每一操作皆均攤 $\theta(1)$ 完成。首先，我們需要充分認知編碼相互轉換的公式，藉以在算法中完成每一步皆為 $\theta(1)$ 的要求。

在上一節提出對於任意編號 $\mathit{tid}$ 可以在 $O(n)$ 時間內得到 $\langle\mathit{lsz},\mathit{lid},\mathit{rsz},\mathit{rid}\rangle$；
相反地，可以在 $\theta(1)$ 時間內逆推得到 $\mathit{tid}$，如算法 ~\ref{alg:encode-tid}。
透過預處理，事先將所有前綴和保存下來，在算法中的迴圈可視為一次內存存取，使得時間複雜度 $\theta(1)$。
\fi

\input{algorithms/alg-encode-tid}

By the recursive formula,  we could implement without storing full
cartesian tree.  The rightmost path is consisted of the root, the
right child of the root, the right child of the right child of the
root, ..., and so on.  We maintain the rightmost path of a Cartesian
tree as a stack.  The algorithm \ref{alg :cartesian-encode-offline} is
shown for offline encoding any cartesian tree.

\iffalse
根據先前的字典順序編碼，只需要維護笛卡爾樹的右鏈，實作上與堆疊結構相同。
基於 row-major 順序和遞迴定義 ~\ref{fun:LCA}，修改之前論文對於的離線編碼，
其對應方案如算法 \ref{alg:cartesian-encode-offline}。
\fi

\input{algorithms/alg-cartesian-encode-offline}

In order to support online encoding, we use 5 variable to present the
state of the cartesian tree.  The next step will insert $i$-th
elements and final stage fill $s$ number of elements.  The current
tree label is $\mathit{tid}$ and the rightmost path of the Cartesian
tree is presented by two variable, stack pointer $\mathit{Dp}$ and the
stack $\mathit{D}$. The structure of state is as follows:

\iffalse
我們定義轉移狀態由 5 個變數來決定動態笛卡爾樹的編碼，當前插入第 $i$ 個元素，最終填充 $s$ 個元素，
當前的樹編號 $\mathit{tid}$，以及笛卡爾樹的右鏈狀態指針 $Dp$ 與其堆疊 $D$，其結構如下：
\fi

\begin{minipage}{0.9\linewidth}
\begin{lstlisting}[frame=single,caption=State of Cartesian Tree]
struct Node {
  int lsz, lid, val;
};
struct State {
  int i, s, tid, Dp;
  struct Node D[s+1];
  State(i = 0, s = n, 
          tid = C[n]-1, Dp = 0,
           D[0].val = INF)
};
\end{lstlisting}
\end{minipage}

For the online query, we choose $s=\frac{\log n}{4}$ by the Fischer's
RMQ.  In our encoding method, we initialize the $s$ number of virtual
node on the rightmost path, so the default tree label $\mathit{tid}$
is $C_s - 1$, which $C_s$ is the $s$-th Catalan number.  Following the
elements insertion, we assume the sequence of elements which is not
yet inserted are increasing.

Because of lexicographical order, the rightmost path of Cartesian tree
is belonged to the lower dimension in the row-major like.
Simultaneously, building a cartesian tree only modify the rightmost
path. We can use the propagation characteristics to get the identity
of the tree.  Finally, we design the difference algorithm
\ref{alg:cartesian-encode-online} to satisfy above requirement.

\iffalse
為了解決在線詢問操作，取 $s = \frac{\log n}{4}$。
根據字典順序的編碼性質，一開始建立虛設點 $s$ 個在右鏈上，其樹編號 $\mathit{tid} = C_s - 1$ 。
隨著插入元素的增加，尚未加入的元素都預設嚴格遞減，加上根據編碼順序，我們藉由差值來維護在線編碼 (如圖 ~\ref{fig:cartesianEncoding})。
根據上述的編碼想法，我們得到算法 ~\ref{alg:cartesian-encode-online}。
\fi

\input{algorithms/alg-cartesian-encode-online}

\begin{figure*}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-cartesian-encoding.pdf}

  \caption{
Each block has $s$ number of elements.  We will build a cartesian tree
with $s$ number of nodes to solve in-block query.  In initialization,
it assume $s$ number of nodes on the rightmost path and the default
tree label $\mathit{tid} = C_s - 1$.  When inserting $i$-th element,
the tree label is $\mathit{tid}_i$, and the tree label of the subtree
$A$ is $A.\mathit{tid}$.  If the value of $(i+1)$-th element is $x$,
it will rotate onto the node $A$.  After rotation, $A$ is a left
subtree of $A$, and we can compute the identify of subtree $A$ during
rotation.  Then, $x.\mathit{tid}$ can be computed by the $s-(i+1)$
number of virtual nodes on the rightmost path and $A.\mathit{tid}$.
According to the lexicographical order, we get $\mathit{tid}_{i+1} =
\mathit{tid}_i + (x.\mathit{tid} - A.\mathit{tid})$.
}

  \label{fig:cartesianEncoding}
\end{figure*}

Finally, we do not increase the time complexity of the building
cartesian tree algorithm because each operation is $O(1)$.  For the
in-block query, we get the identity of the cartesian tree in $O(1)$,
and look up table to find the result.

\iffalse
最後，我們不改變原本的建立笛卡爾樹算法，便能在過程中擭得樹的編號，
每一次的 in-block 詢問只需要一次記憶體存取，得到任一操作攤銷複雜度 $\theta(1)$。
\fi
