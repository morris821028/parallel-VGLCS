\section{Implementation}
\label{sec:Implementation}

\subsection{The Strategy of Disjoint Set}

The space complexity of VGLCS problem is $\theta(n^2)$.  The merging
of disjoint set has two main strategies, path compression, and rank
strategy \cite{Patwary2010ExperimentsOU}.  The impact of
implementation will encounter different level of cache miss.  We
choose one of them to improve the performance and avoid use both of
them to cause more cache miss.

\iffalse
運行 VGLCS 時，將耗費 $\theta(n^2)$ 的內存空間。使用遞增後綴最大值 (ISMQ) 時，
採用並查集實作將會遭遇到很多不平衡的工作負載，其原因在於合併的策略，
常見的有路徑壓縮和啟發式合併兩種策略，這間接影響到不同次數的分枝判斷。
實務上須考慮到快取未中，故兩種策略只能擇其一，兩者皆用將引發更多的快取未中而導致效能下滑。
\fi

In the parallel algorithm, a disjoint set must be processed by a
thread.  We tend to use lazy propagation because of the cache miss.
Due to the tendency of the dynamic programming, there are two cases in
which the trend of the inserted value.  The first case is the
continuous zero value insert because it violates the definition.  The
second case is the insertion of incremental elements.  Finally, we can
use the lazy propagation to improve the performance in implementation.

\iffalse
每個執行緒負責數個完整的并查集，操作時應偏向延遲標記操作，
儘早合併的策略易造成快取未中。由於動態規劃的傾向中，插入值的趨勢有兩種情況，
其一為連續不合定義的零元素插入，其二為遞增元素的插入，在這兩者穿插的趨勢中，
我們發現延遲操作將會帶來較能改善快取未中問題。
\fi

\subsection{Parallel Range Query}

We often use the built-in function to get the logarithm in $O(1)$.
However, we can pre-compute all the result of the logarithm in dynamic
programming.  Each the logarithm of range for each query stores into
the array, and it can reduce the number of instructions.

Because we know the information of range query, we can limit the
computation boundary for building sparse table.  The algorithm
\ref{alg:reduce-boundary} is a dynamic programming for shrink
computation boundary which runs in $O(n \log n)$.  Finally, the
parallel VGLCS algorithm run in $O(n \log n)$ time, so the dynamic
programming do not increase the time complexity.

\input{algorithms/alg-reduce-boundary}

Due to small $s = \frac{\log n}{4}$, the in-block query is a very
small probability event.  We can use prefix and suffix maximum array
to instead of the look-up table.  In our application, we even predict
whether the cartesian tree is necessary to use for the in-block query.
If not, we can reduce time to compute it.  These two arrays brought
$O(n)$ space, but improve the performance by strength reduction.
