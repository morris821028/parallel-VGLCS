\section{Introduction} %Introduction
\label{sec:Introduction}

% This is a topic sentence by itself.
% say something about sequence alignment

The {\em longest common subsequence} (LCS)~\cite{Hirschberg1975ALS} is
a famous problem in string processing.  For example, the {\tt diff}
utility show the difference between texts by finding their LCS.
Revision control systems like SVN and Git use LCS to reconciling
multiple changes.  In bioinformatics, the best-known application of
the LCS problem is the sequence
alignment~\cite{mount2001bioinformatics, Ann2010EfficientAF}, which
identifies the region of similarity between the sequences of DNA, RND,
or protein.


\iffalse 最長共同子序列 (\emph{longest common subsequence}, LCS) 廣泛
地使用在各個應用上。在多核心平台下，大多數的研究專注於如何高效率地在波
前平行 (wavefront parallelism)，而 Jiaoyun Yang ~\cite{jiaoyun} 提出的
論文中改變一般的 LCS 遞迴定義以得到更好快取使用率。在這篇論文中，針對
在 Iliopoulos 和 Rahman ~\cite{iliopoulos} 提及的約束條件下的 LCS 問題
使用相關的想法來改善效能。\fi

% give citation

Iliopoulos and Rahman~\cite{Rahman2006AlgorithmsFC} introduced many
constrained versions of LCS.  For example, a {\em fixed gap LCS}
(FGLCS) requires that the distance between consecutive characters in
the LCS is {\em at most} $k + 1$ characters away.  A fixed gap LCS can
be found in time $O(nm)$, where $n$ and $m$ are the lengths of the two
input strings~\cite{citation}.  On the other hand, a {\em variable gap
  LCS} (VGLCS) requires that each character has a {\em gap} value and
two consecutive characters in LCS must be with distance of the gap of
the {\em latter} character {\em plus} 1.  One can think of the fixed
gap LCS as a special case of variable gap LCS in which the gap values
of all characters are $k$.

\begin{figure}[!thb]
  \centering
  \includegraphics[width=0.8\linewidth]{graphics/fig-VGLCSex.pdf}
  \includegraphics[width=0.8\linewidth]{graphics/fig-VGLCSex2.pdf}
  \caption{A VGLCS example} \label{fig:VGLCSex}
\end{figure}

We use an example to illustrate the gap function and VGLCS.  Let string
$A$ be {\tt GCGCAATG} with gap values $(3, 1, 1, 2, 0, 0, 2, 1)$, and
let string $B$ be {\tt GCCCTAGCG} with gap values $(2, 0, 3, 2, 0, 1,
2, 0, 1)$.  Please refer to Figure~\ref{fig:VGLCSex} for an
illustration.  Now the LCS $GCCT$ is a VGLCS because every character
in the LCS can find its predecessor in the LCS with distance at most
its gap value plus 1.

This paper focuses on {\em efficient parallel algorithms} that find
VGLCS.  Peng~\cite{Peng2011TheLC} gives a $O(nm \alpha(n))$ algorithm
that is easy to implement and an asymptotically better $O(nm)$
algorithm, where $\alpha$ is the inverse of Ackermainn's
function~\cite{Banachowski1980ACT}.  In this paper we propose our
$O(nm)$ algorithm which is {\em easy} to implement and runs {\em
  efficiently} in a {\em parallel} environment.

% then we???

The parallelization of LCS on most multi-core platforms focuses on
{\em wavefront} parallelism.  The wavefront parallelism is motivated
by the recursive solution of LCS.  For example,
Yang~\cite{Yang2010AnEP} introduced a new formulation to exploit more
cache performance.  Our algorithm uses a more powerful {\em sparse
  table} instead of the disjoint set in the Peng's serial algorithm
and achieves better cache performance.

% Then we will ???

\iffalse 在約束條件下的 LCS 中，如 \emph{fixed gap LCS } (FGLCS)要求任
兩個挑選的距離在相對應的另一個字串中相等，同時距離最大為 $k+1$，可在時
間複雜度在 $O(nm)$ 內解決，其中 $n$, $m$ 分別為兩個輸入的字串長度。我
們將在這篇論文針對 \emph{variable gap LCS} (VGLCS) 進行探討。在 VGLCS
中，對各個不同的位置提供約束限制，如目前給定兩個字串 $A =
\tt{GCGCAATG}$, $B = \tt{GCCCTAGCG}$，各自的約束限制為 $G_A = [3, 1,
  1, 2, 0, 0, 2, 1]$ 和 $G_B = [2, 0, 3, 2, 0, 1, 2, 0, 1]$，其中
$G_A(i)$ 表示當挑選第 $i$ 個位置時，與前一個挑選的位置最多差
$G_A(i)+1$，同理 $G_B(i)$；我們可以得到兩組 VGLCS 的解
$\tt{G..C..C..A}$ 和 $\tt{G..C..C..T}$，挑選的方式如圖
~\ref{fig:VGLCSex}。在 Yung-Hsing Peng ~\cite{yunghsing} 的論文已對
VGLCS 提出易於實作的 $O(nm \alpha(n))$ 和理論 $O(nm)$ 的解法。\fi

% Use reference in all section numbering

The remainder of the paper is organized as follows.  In
Section~\ref{sec:parallelVGLCS}, we present previous parallel
algorithms for finding VGLCS.  In Section~\ref{sec:parallelRMQ} and
\ref{sec:parallelIRMQ}, we present our algorithm that is easy to
parallelize, and has a time complexity $O(nm)$, which is better than
previous works.  In Section~\ref{sec:Implementation} and
\ref{sec:Experiment}, we describe our optimized implementation and the
results of our experiments.  Section~\ref{sec:Conclusion} conclude
this paper with lessons learned and possible future works.

\iffalse 這一篇論文，我們將在第二 \ref{sec:parallelVGLCS} 節部分將
Yung-Hsing Peng ~\cite{yunghsing} 提出的算法進行平行化。在第三節
~\ref{sec:parallelRMQ}，在理論分析上提供易平行且時間複雜度 $O(nm)$ 的
設計。在第四節 ~\ref{sec:Implementation}，我們將藉由快取忘卻
(cache-oblivious) 技術，在實作上提供更好的效能。最後，我們總結實驗結果
與理論實務上的差異。\fi

