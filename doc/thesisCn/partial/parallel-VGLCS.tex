\section{平行化序列算法} %
\label{sec:parallelSerial}

在 $O(nm \alpha(n))$ 的序列算法中 (參照算法 ~\ref{alg:serial-VGLCS})，我們發現算法如大多數的變型 LCS 相同，依賴數個狀態以轉移當前狀態，大量的資料依賴性不易於細粒度平行。使用波前運行平行是一種常見的解決方案，由於這種平行對於運行時的快取不友善 (cache-unfriendly)，所以在 Saeed Maleki ~\cite{saeed} 論文中提到如何使用 Rank Convergence 的特殊性質，拓展出更高平行度來解決動態規劃的相關問題。

\input{algorithms/alg-serial-VGLCS}

序列算法的空間複雜度為 $O(nm)$。若使用波前平行，需要同時維護橫向的所有狀態，需要多付出一倍的空間量。若加入 Rank Convergence 的想法拓展出，勢必要記錄轉移的狀態，需要耗費更多的記憶體空間，用以在最後階段合併所用。

這裡我們傾向空間複雜度常數小且針對快取友善設計算法。平行算法主要分成兩個階段－縱向和橫向階段，縱向階段為數個列的後綴極值查找，橫向階段在行上運行 $n$ 個元素和 $n$ 組詢問。我們發現在橫向查找中使用 $O(\alpha(n))$ 操作的增長後綴最大值查找 (\emph{incremental suffix maximum query}, ISMQ)，在過程中每插入一個元素便改動數據結構以支持下一個後綴詢問，這使得查詢難以平行化。為消除資料相依性，我們找到幾種區間詢問的替代方案。如：

\begin{itemize}
  \item 樹狀數組 (Binary Indexed Tree) -- $O(\log n)$: 對於任意前綴查找極值和更新元素，可以提供每次時間複雜度 $O(\log n)$，其運行常數比 Range Tree 低，只能支持前綴查找。若要運行區間查找，則必須在數學上符合加法原則。
  \item 線段樹 (Segment Tree) -- $O(\log n)$: 支持更高維度的正交區塊搜索，而我們用在區間極值查找需要 $O(\log n)$ 的時間完成所有區間查詢操作。
  \item 稀疏表 (Sparse Table) -- $O(n)$ -- $O(1)$:
    建立表格 $ST[j][i]$ 表示區間 $(i-2^j,i]$ 之間的極值。建表時間複雜度需 $O(n)$，對於任意區間詢問可以拆分 2 個 super-block 檢索和 2 個 in-block 檢索 (參照圖 ~\ref{fig:interval-decomposition} 的說明)，轉換過程和存取時間皆需要 $O(1)$。
\end{itemize}

\begin{figure*}[!thb]
  \centering
  \includegraphics[width=\linewidth]{graphics/fig-interval-decomposition.pdf}
  \includegraphics[width=\linewidth]{graphics/fig-sparse-table.pdf}
  \caption{給定一陣列 $A$ 如上圖所述，並且拆成 5 個區塊，每個區塊皆有 4 個元素，若詢問區間 $[2, 18]$ 的最大值，將分成 $B1$ 的內部詢問 (in-block query) $Q_L$、$B5$ 的內部詢問 $Q_R$ 和兩個跨區間詢問 (super-block query) $SQ_L$、$SQ_R$}
  \label{fig:interval-decomposition}
\end{figure*}

稀疏表是我們認為最好的替代方案，其整合後為 VGLCS 平行算法 ~\ref{alg:parallel-VGLCS}，算法的時間複雜度為 $O(n^2 \alpha(n) / p + n \log n)$，其中 $p$ 為處理器個數。在後續的章節，我們將提出新的數據結構取代并查集操作，使得序列算法的時間複雜度從 $O(n^2 \alpha(n))$ 降至 $O(n^2)$，且能在平行算法達到理想複雜度 $O(n^2 / p + n \log n)$。

\input{algorithms/alg-parallel-VGLCS}